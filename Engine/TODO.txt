Попробовать реализовать глобальную dllexport переменную для взаимодействия всех систем движка с графическим интерфейсом  ****Сделано через интерфейс ISystem****
###
Возможно для режима редактора, где будут часто меняться шейдеры для каждой модели стоит использовать один большой формат вершин, который содержит весь набор данных(тратится больше видеопамяти, но переключение между шейдерами быстрое и просто реализуется с помощью InputLayout),
а для игрового режима каждой модели задается тип вершин, определяемый шейдером и модель загружается в память в соответствии с ним. Так же можно включить опцию для модели работать в игровом режиме так как в редакторе если для игры требуется динамически менять шейдер для этой модели.
UPD.: правильнее наверно будет реализовать автоматический(статичный) режим (прежний игровой) и ручной(для возможности динамичного переключения шейдеров), в котором задается вручную тип вершин из перечисления VertexTypes это позволит быть ему более эффективным в плане траты видеопамяти. 
InputLayout в этом случае у каждого шейдера должен обеспечивать его совместимость с заданным типом вершин, что потенциально ведет к большому количеству кода необходимого для одного шейдера.
###
Можно попробовать все не игровые классы (системные) наследовать от одного базового (например ISystemObject или IService) который будет содержать в себе механизм создания потока для этой службы или предоставлять указатель на функцию потока
###
Отдельный буфер в шейдере для его параметров (типа Specularity, glossines, и т д)
###
1)сцена содержит переменные окружающей среды.
2)у каждой переменной есть описание .
3)у каждой переменной есть строковый (?) идентификатор.
4)в редакторе выбирается перечень переменных окружения.
5)перечень переменных заносится в файл шейдера при компиляции в виде их идентификаторов.
6)при загрузке шейдера подсчитывается общее количество памяти, требуемой для переменных
7)определяется структура памяти с помощью вектора сдвигов в памяти на основе перечня идентификаторов.
8)фактически это runtime generic struct. можно сделать отдельный класс.
9)один буфер - один RGS
10)для инициализации RGS принимает vector<pair<string,void*» в котором содержатся его типы данных и указатели на переменные среды.
11)RGS берет на себя выделение памяти под переменные, её разметку, обновление.
12)обновление подразумевает под собой копирование данных из сцены в буфер RGS.
13)указатели предоставляются сценой по вызову метода, отвечающего за это. примерная сигнатура:
void** getPtrs(vector<string>* IDs);
IDs это идентификаторы переменных среды, берутся из *.acs файла.
14)RGS должен возвращать указатель на свою память и её размер которые затем можно применять для инициализации d3dbuffer-a и его обновления.
###